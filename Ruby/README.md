### Ruby is ... ðŸ§

Ð ÑƒÐ±Ð¸ - Ð½Ð°ÑÑ‚Ð¾ÑÑ‰Ð¸Ð¹ Ð´Ð¸Ð½Ð°Ð¼Ð¸Ñ‡ÐµÑÐºÐ¸Ð¹ Ð¾Ð±ÑŠÐµÐºÑ‚Ð½Ð¾-Ð¾Ñ€Ð¸ÐµÐ½Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹, Ð¸Ð½Ñ‚ÐµÑ€Ð¿Ñ€ÐµÑ‚Ð¸Ñ€ÑƒÐµÐ¼Ñ‹Ð¹, ÑÐ·Ñ‹Ðº ÑÐ²ÐµÑ€Ñ…Ð²Ñ‹ÑÐ¾ÐºÐ¾Ð³Ð¾ ÑƒÑ€Ð¾Ð²Ð½Ñ. 

---

### ÐžÐžÐŸ

ÐžÐ±ÑŠÐµÐºÑ‚ - ÑÑƒÑ‰Ð½Ð¾ÑÑ‚ÑŒ ÑÐ»ÑƒÐ¶Ð°Ñ‰Ð°Ñ ÐºÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€Ð¾Ð¼ Ð´Ð»Ñ Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ñ Ð¸ ÑƒÐ¿Ñ€Ð°Ð²Ð»ÑÑŽÑ‰Ð°Ñ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð¾Ð¼ Ðº ÑÑ‚Ð¸Ð¼ Ð´Ð°Ð½Ð½Ñ‹Ð¼. 
**Ð˜Ð½ÐºÐ°Ð¿ÑÑƒÐ»ÑÑ†Ð¸Ñ** - Ð¾Ð±Ð»Ð°ÑÑ‚ÑŒ Ð²Ð¸Ð´Ð¸Ð¼Ð¾ÑÑ‚Ð¸ Ð°Ñ‚Ñ€Ð¸Ð±ÑƒÑ‚Ð¾Ð² Ð¸ Ð¼ÐµÑ‚Ð¾Ð´Ð¾Ð² Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ Ð¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð° ÑÐ°Ð¼Ð¸Ð¼ Ð¾Ð±ÑŠÐµÐºÑ‚Ð¾Ð¼. 
**ÐÐ°ÑÐ»ÐµÐ´Ð¾Ð²Ð°Ð½Ð¸Ðµ** - Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð½Ð¾Ð²Ñ‹Ñ… Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ÑÑ‚ÐµÐ¹ Ð¿ÐµÑ‚ÐµÐ¼ Ñ€Ð°Ð·ÑˆÐ¸Ñ€ÐµÐ½Ð¸Ñ Ñ€Ð°Ð½ÐµÐµ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð½ÑƒÑŽ ÑÑƒÑ‰Ð½Ð¾ÑÑ‚ÑŒ, Ð½Ð°ÑÐ´ÑƒÑŽÑ‚ÑŒÑÑ Ð²ÑÐµ Ð°Ñ‚Ñ€Ð¸Ð±ÑƒÑ‚Ñ‹ Ð¸ Ð¼ÐµÑ‚Ð¾Ð´Ñ‹ ÐºÐ»Ð°ÑÑÐ°. 
**ÐŸÐ¾Ð»Ð¸Ð¼Ð¾Ñ€Ñ„Ð¸Ð·Ð¼** - Ð¿Ñ€Ð¸Ð½Ð¸Ð¼Ð°Ñ‚ÑŒ Ñ€Ð°Ð·Ð½Ñ‹Ðµ Ñ„Ð¾Ñ€Ð¼Ñ‹ Ð¸Ð»Ð¸ Ð¾Ð±Ð»Ð¸Ñ‡Ð¸Ñ. *ÐÐ°ÑÐ»ÐµÐ´ÑÑ‚Ð²Ñ€ÐµÐ½Ð½Ñ‹Ð¹ Ð¿Ð¾Ð»Ð¸Ð¼Ð¾Ñ€Ñ„Ð¸Ð·Ð¼* - Ð²ÑÐµ Ð¼ÐµÑ‚Ð¾Ð´Ñ‹ ÑÑƒÐ¿ÐµÑ€ÐºÐ»Ð°ÑÑÐ° Ð¿Ñ€ÐµÑÑƒÑ‚ÑÑ‚Ð²ÑƒÑŽÑ‚ Ð¸ Ð² Ð¿Ð¾Ð´ÐºÐ»Ð°ÑÐµ ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ ÐµÐ³Ð¾ Ð½Ð°ÑÐ»ÐµÐ´ÑƒÐµÑ‚. Ð˜Ð½Ñ‚ÐµÑ€Ñ„ÐµÐ¹ÑÐ½Ñ‹Ð¹ Ð¿Ð¾Ð»Ð¸Ð¼Ð¾Ñ€Ñ„Ð¸Ð·Ð¼ - Ð¿Ð¾Ð·Ð²Ð¾ÑÐ»ÐµÑ‚ Ð¿Ð¾Ð´Ð¼ÐµÑˆÐ¸Ð²Ð°Ñ‚ÑŒ Ð¼ÐµÑ‚Ð¾Ð´Ñ‹ Ðº ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÑŽÑ‰Ð¸Ð¼ ÐºÐ»Ð°ÑÑÐ°Ð¼?.

---

> ÐžÐ±ÑŠÐµÐºÑ‚ - ÑÐºÐ·ÐµÐ¼Ð¿Ð»ÑÑ€ ÐºÐ»Ð°ÑÑÐ° Ð¾Ð±ÑŠÐµÐºÑ‚Ð°  
> Ñ‚ÐµÑ€Ð¼Ð¸Ð½Ñ‹ "Ð¼Ð¾Ð´ÑƒÐ»ÑŒ" Ð¸ "Ð¿Ñ€Ð¸Ð¼Ð¸ÑÑŒ" Ð¸Ð´ÐµÐ½Ñ‚Ð¸Ñ‡Ð½Ñ‹
> ÐšÐ»Ð°Ñ - Ð°Ð±ÑÑ‚Ñ€Ð°ÐºÑ‚Ð½Ñ‹Ð¹ Ñ‚Ð¸Ð¿  
> Ð•ÑÐ»Ð¸ Ð‘ Ð½Ð°ÑÐ»ÐµÐ´ÑƒÐµÑ‚ Ð, Ñ‚Ð¾ Ð - ÑÑƒÐ¿ÐµÑ€ÐºÐ»Ð°Ñ, Ð±Ð°Ð·Ð¾Ð²Ñ‹Ð¹ Ð¸Ð»Ð¸ Ñ€Ð¾Ð´Ð¸Ñ‚ÐµÐ»ÑŒÑÐºÐ¸Ð¹, Ð‘ - Ð¿Ð¾Ð´ÐºÐ»Ð°ÑÑ, Ð´Ð¾Ñ‡ÐµÑ€Ð½Ñ‹Ð¹ Ð¸Ð»Ð¸ Ð¿Ñ€Ð¾Ð¸Ð·Ð²Ð¾Ð´Ð½Ñ‹Ð¹. 
> Ð’ Ð¿Ð¾Ð´ÐºÐ»Ð°ÑÑÐ° ÐµÑÑ‚ÑŒ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ÑÑ‚ÑŒ Ð²Ñ‹Ð·Ð²Ð°Ñ‚ÑŒ Ð¸Ð· Ð¿ÐµÑ€ÐµÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð½Ð¾Ð³Ð¾ Ð¼ÐµÑ‚Ð¾Ð´Ð° Ð¼ÐµÑ‚Ð¾Ð´ Ð±Ð°Ð·Ð¾Ð²Ð¾Ð³Ð¾ ÐºÐ»Ð°ÑÑÐ° Ñ Ñ‚ÐµÐ¼ Ð¶Ðµ Ð¸Ð¼ÐµÐ½Ð¼. 
> Ð”Ð»Ñ ÑÑ‚Ñ€Ð¾Ðº ÐµÑÑ‚ÑŒ ÑÐ¿ÐµÑ†Ð¸Ð°Ð»ÑŒÐ½Ñ‹Ð¹ ÑÐ¸Ð½Ñ‚Ð°ÐºÑÐ¸Ñ: %w[Jan Feb Apr]
> Ð¥ÐµÑˆÐ¸ - Ð°ÑÑÐ¾Ñ†Ð¸Ð°Ñ‚Ð¸Ð²Ð½Ñ‹Ðµ Ð¼Ð°ÑÑÐ¸Ð²Ñ‹ Ð¸Ð»Ð¸ ÑÐ»Ð¾Ð²Ð°Ñ€Ð¸, Ð² ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ðµ ÐºÐ»ÑŽÑ‡Ð° Ð¼Ð¾Ð¶ÐµÑ‚ Ð±Ñ‹Ñ‚ÑŒ ÐµÐºÐ·. ÐºÐ»Ð°ÑÑÐ° Symbol.
> Math::PI - Ð¾Ð´Ð¸Ð½ Ð¸Ð· ÑÐ¿Ð¾ÑÐ¾Ð±Ð¾Ð² Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ Ð¼Ð¾Ð´ÑƒÐ»ÐµÐ¹
> load - Ð¾Ð¿ÐµÑ€Ð°Ñ†Ð¸Ñ Ñ‡Ð¸Ñ‚Ð°ÐµÑ‚ Ñ„Ð°Ð¹Ð» Ð¸ Ð¸ÑÐ¿Ð¾Ð»Ð½ÑÐµÑ‚ ÐµÐ³Ð¾ Ð² Ñ‚ÐµÐºÑƒÑ‰ÐµÐ¼ ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ðµ
> require - Ð°Ð½Ð°Ð»Ð¾Ð³Ð¸Ñ‡Ð½Ð° load, Ð½Ð¾ Ð½Ðµ Ð·Ð°Ð³Ñ€ÑƒÐ¶Ð°ÐµÑ‚ Ñ„Ð°Ð¹Ð» ÐµÑÐ»Ð¸ Ð¾Ð½ ÑƒÐ¶Ðµ Ð±Ñ‹Ð» Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½  

---

> irb - Ð¸Ð½Ñ‚ÐµÑ€Ð°ÐºÑ‚Ð¸Ð²Ð½Ð°Ñ Ð¾Ð±Ð¾Ð»Ð¾Ñ‡ÐºÐ° 
> ÐžÐ´Ð¸Ð¼ Ð¸Ð· ÑÐ°Ð¼Ñ‹Ñ… Ð¼Ð¾Ñ‰Ð½Ð½Ñ‹Ñ… Ð¿ÐµÑ€ÐµÐ¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÑÐµÐ¼Ñ‹Ñ… Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð² ÑÐ²Ð»ÑÐµÑ‚ÑÑ **[]** ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÑŽÑ‚ *Array* Ð¸ *Hash*.  
> ÐœÐµÑ‚Ð¾Ð´Ñ‹ Ð¸Ð»Ð¸ Ñ„ÑƒÐ½Ñ†Ð¸Ð¸ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð½Ñ‹Ðµ Ð·Ð° Ð¿Ñ€ÐµÐ´ÐµÐ»Ð°Ð¼Ð¸ ÐºÐ»Ð°ÑÑÐ° Ð¸Ð»Ð¸ Ð¼Ð¾Ð´ÑƒÐ»Ñ ÑÐ²Ð»ÑÑŽÑ‚ÑÑ Ð³Ð»Ð¾Ð±Ð°Ð»ÑŒÐ½Ð¾Ð¹ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÐµÐ¹( Ð¸Ð»Ð¸ Ð¼ÐµÑ‚Ð¾Ð´Ð¾Ð¼ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Object).  
> ÐšÐ»Ð°ÑÑÑ‹ Ð¸ Ð¼ÐµÑ‚Ð¾Ð´Ñ‹ ÑÐ²Ð»ÑÑŽÑ‚ÑÑ Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚Ñ‹Ð¼Ð¸ Ð¸ Ð¼Ð¾Ð³ÑƒÑ‚ Ð±Ñ‹Ñ‚ÑŒ Ð¼Ð¾Ð´Ð¸Ñ„Ð¸Ñ†Ð¸Ñ€Ð¾Ð²Ð°Ð½Ñ‹ Ð¸ Ñ€Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ñ‹ Ð² Ð¿Ñ€Ð¾Ñ†ÐµÑÑÐµ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹.  
> ? - Ð¾Ð±Ð¾Ð·Ð½Ð°Ñ‡Ð°ÐµÑ‚ Ð¼ÐµÑ‚Ð¾Ð´Ñ‹ ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÑŽÑ‚ Ð±ÑƒÐ»ÐµÐ²Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ
> ! - Ð¼ÐµÑ‚Ð¾Ð´-Ð¼ÑƒÑ‚Ð°Ñ‚Ð¾Ñ€ - Ð¸Ð·Ð¼ÐµÐ½ÑÐµÑ‚ Ð½ÐµÐ¿Ð¾ÑÑ‚Ñ€ÐµÐ´ÑÑ‚Ð²ÐµÐ½Ð½Ð¾ ÑÐ°Ð¼ Ð¾Ð±ÑŠÐµÐºÑ‚
> $ - Ð³Ð»Ð¾Ð±Ð°Ð»ÑŒÐ½Ñ‹Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ (Ð¿Ñ€Ð¸ÑˆÐµÐ» Ð¸Ð· Perl)
> @ - Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ ÑÐºÐ·ÐµÐ¼Ð¿Ð»ÑÑ€Ð¾Ð² 
> @@ - Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ ÐºÐ»Ð°ÑÑÐ°
> \# - Ð¼ÐµÑ‚Ð¾Ð´ ÑÐºÐ·ÐµÐ¼Ð¿Ð»ÑÑ€Ð° -> String#crypt

---

1. Why Ruby
	- high-level - look a lot like a regular English.
	- Interpreted, you don't need a compiler to write and run Ruby. 
	- Object-oriented 
	- Easy to use, developed by Matz, he set out to design a language that 	emphasized 
	human needs over those of the computer, which is why Ruby is so easy to pick up.

1. Data types:
	- Numeric
	- Boolean 
	- String
 

1. Math operators:
	- Addition ( + )
	- Subtraction ( - )
	- Multiplication ( * )
	- Division ( / )
	- Exponentiation ( ** )
	- Modul0 ( % )
	- Assignment operator ( = )
	- comparator ( == )
	- not equal ( != )
	- less than or equal to (< =)
	- greater than or equal to ( > = )
	- and ( && )
	- or ( || )

1. puts and print 
	- puts like print but add to the and return 
	- print - view in the terminal given value 

1. Methods 
	- /# for Single-line comment 
	- =begin / =end multi-line comments
	- ! modifies the value contained whithin the variable itself
	- ? 
	- { } is the same as do end

---

1. Error message -> throw new exception
  - raise "Text to be displayed" 
  - raise ArgumentError, "Text to be displayed"
  - raise ArgumentError.new("Text to be displayed")
  - begin
  - # text ...
  - end
  - rescue => variable - Ð´Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ Ð¼Ð¾Ð¶Ð½Ð¾ ÑƒÐºÐ°Ð·Ð°Ñ‚ÑŒ Ñ‚Ð¸Ð¿ Ð¾ÑˆÐ¸Ð±ÐºÐ¸

1. Control flow
	- if statement => should be indented two spaces
		- if user_num => 0
		- elsif user_num > 0 
		- else "print this"
		- end
    - while || until -> redo ÐºÐ»ÑŽÑ‡ÐµÐ²Ð¾Ðµ ÑÐ»Ð¾Ð²Ð¾ ÐºÐ°Ðº retry
    - next -> Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´ Ð½Ð° ÐºÐ¾Ð½ÐµÑ† ÑÐ°Ð¼Ð¾Ð³Ð¾ Ð²Ð½ÑƒÑ‚Ñ€ÐµÐ½Ð½ÐµÐ³Ð¾ Ñ†Ð¸ÐºÐ»Ð° 

```ruby
my_num = 12
if my_num > 0
  print "greater than 0"
elsif my_num < 0
  print "is less than 0"
else
  print "Your number is 0"
end
```

- unless => to check if somth is false
	- unless variable
	- else 
	- end
- loop do break
- for i in 1..5 next if end 
 
	
1. Logical or boolean operators 
	- && and - cheak for false 
	- || or => cheak for true 
	- ! - Not 

```ruby 
request_is_successful = false
print "Request is #{request_is_successful}" unless request_is_successful
```

1. Prioryty of && and || in Ruby 

```ruby 
print "Print the sentence:"
user_input = gets.chomp
user_input.downcase!

if user_input.include? "s"
  user_input.gsub!(/s/, "th")
  puts "We found \"s\" and here your sentence: #{user_input}"
else
  print "Not found \"s\""
end
```

```ruby
# while 

counter = 1
while counter < 11
  puts counter
  counter = counter + 1
end

# until 

counter = 1
until counter > 10
  puts counter
  counter += 1
end

for num in 1...10
  puts num
end

# loop do | break 

i = 20
loop do
  i -= 1
  puts "#{i}"
break if i <= 0
end

# loop do | next if | break if 

i = 20
loop do
  i -= 1
  next if i % 2 != 0
  print "#{i} "
break if i <= 0
end

# each do |

array = [1,2,3,4,5]

array.each do |x|
  x += 10
  print "#{x} "
end

# method times 

150.times { print "Hello"}

# while looping 

i = 1
while i <= 50 do 
  print "#{i}" 
  i += 1
end

for i in 1..50 
  print "#{i}" 
end

# loop do break if 

i = 0
loop do
  i += 1
  print "Ruby!"
  break if i == 30
end

# time { } || do end 

30.times { print "Ruby!" } 

# program to change the word in sentence 

puts "Type some words:"
text = gets.chomp 

puts "Type Redacted word:"
redact = gets.chomp

words = text.split(" ")

words.each do |word|
  if word == redact
    print "REDACTED "
  else
    print word + " "
  end
end


```

1. Hashes like JS objects or Python dictionaries 
A collection of key-value pairs
```ruby 
my_hash = { "name" => "Eric",
  "age" => 26,
  "hungry?" => true
}

# or 

my_hash = Hash.new # or {}
pets["cat"] = "Hover"

pets.each { |x, y| "#{x}: #{y}" }

# to iterate inside sub-arrays 

s.each { |e| 
  e.each { |i| puts i}
}

# or

secret_identities.each do |key, val| 
  puts "#{val}: #{val}"
end
```

1. From user input to hash => histogram
```ruby
puts "Please, type some sentences:"
text = gets.chomp

words = text.split(" ")

frequencies = Hash.new(0)
words.each { |word| frequencies[word] += 1}

frequencies = frequencies.sort_by do |word, count|
  count
end
frequencies.reverse!

frequencies.each do |name, count|
  puts "#{name} #{count.to_s}"
end
```

1. Method Syntax 
- def => keyword from start || end
- \*args - splat arguments
- { } or do end => like Nameless Methods

```ruby 
def puts_1_to_10(n)
  (1..10).each { |i| puts i }
end

puts_1_to_10(10)

# using splat arguments

def what_up(greeting, *friends)
  friends.each { |friend| puts "#{greeting}, #{friend}!" }
end

what_up("What's up", "Ian", "Zoe", "Zenas", "Eleanor")

def capitalize(string) 
  puts "#{string[0].upcase}#{string[1..-1]}"
end

```

1. The Combined Comparison Operator < = >
- return 0 => 1 == 2 || 1  => 1 > 2|| -1 =>  1 > 2
- if value is string => compare length 
```ruby

books.sort! { |firstBook, secondBook| firstBook <=> secondBook }

# sorting in descending alphabetical order

fruits = ["orange", "apple", "banana", "pear", "grapes"]
fruits.sort! { |f,s| s <=> f}

# revese sorting of arrays 

def alphabetize(arr, rev=false)
  if rev
    arr.sort { |item1, item2| item2 <=> item1 }
  else
    arr.sort { |item1, item2| item1 <=> item2 }
  end
end

books = ["Heart of Darkness", "Code Complete", "The Lorax", "The Prophet", "Absalom, Absalom!"]

puts "A-Z: #{alphabetize(books)}"
puts "Z-A: #{alphabetize(books, true)}"

# Give nil other value

no_nil_hash = Hash.new("Duc")
```

1. Symbol 
- puts :symbol.object_id
- my_first_symbol = :ruby => create a symbol Syntax
- used either as hash keys or for referencing method names
- they are immutable
- save memory
- symbol as a keys faster than strings as key
- to_sym => method to converting string to symbols
- .intern => internalize the string into a symbol and works just like .to_sym
- new 1.9 hash syntax => one: 1,
- .each_key => 
- .each_value => 

```ruby

strings.each { |s| symbols.push(s.to_sym) }

movies = {
  :one => "Terminator 1",
  :two => "Terminator 2",
}

good_movies = movie_ratings.select { |name, rat| rat > 3 }

movie_ratings.each_key { |k| puts k}

# the movies app / add / delete / create / 

movies = {
  The_lord_of_the_rings: 4,
  baz: 1,
}
puts "Type command"
choice = gets.chomp
case choice
  when "add"
    puts "What the name?"
    title = gets.chomp
    title = title.to_sym
    puts "What the rating?"
    rating = gets.chomp
    rating = rating.to_i
    if movies[title] == nil
      movies[title] = rating
    else 
      puts "This movie already exist!"
    end
    puts "We add #{movies[title]}"
  when "update"
    puts "What the movie need to update?"
    title = gets.chomp
    if movies[title] != nil
      puts "No this movie!"
    else 
      puts "Print new rating:"
      movies[title] = gets.chop
    puts "Updated! #{movies[title]}"
    end
  when "display"
    movies.each { |movie, rating| puts "#{movie}: #{rating}" }
  when "delete"
    puts "Print the movie name:"
    title = gets.chomp
    if movies[title] != nil
      puts "Error! Not found the movie named #{title}"
    else
      movies.delete(title.to_sym)
      puts "Now we have movies: #{movies}"
    end
  else
    puts "I don\'t know!"
end
```

1. A simple if condition
You can type like this:
	puts "It's true" if true
	puts "Unless also can do it" unless false
A ternary 
	puts 0 == nil ?  "Yes, true" :  "No, false"

1. When and Then: like switch(expression) { case value1: break; } 

```ruby 
puts "Hello there!"
greeting = gets.chomp

# Add your case statement below!

case greeting
  when "English"
    puts "Hello!"
  when "French"
    puts "Bonjour!"
  when "German"
    puts "Guten Tag!"
  when "Finnish"
    puts "Hallo!"
  else
    puts "I donâ€™t know that language!"
end
```

1. Conditional Assignment 
We can use conditional assignment operator ||= 

```ruby
favorite_book ||= "Cat's Cradle"
puts favorite_book
```

1. Implicit Return 
In Ruby methods will return the result of the last evaluated expression

1. Ruby use Short-Circuit Evaluation 
false && true => it stops reading as soon as it sees False
true && true => return second paramether

```ruby 
my_array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

my_array.each { |e| puts e if e%2 == 0 }
```
1. Up The Down Staircase

95.upto(100) { |num| print num, " " }

1. Method respond_to and next for integer

puts age.respond_to?(:next)

1. Concatenation operator << 
```ruby
[1,2,3] << 4
"I am " << age.to_s << " years old."
```

```ruby

require 'prime'   # This is a module. We'll cover these soon!

def first_n_primes(n)
  return "n must be an integer." unless n.is_a? Integer
  return "n must be greater than 0." if n <= 0
  Prime.first n
end

first_n_primes(10)

[1, 2, 3].each { |num| puts num }

fibs = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
doubled_fibs = fibs.collect { |num| num * 2 }
```

1. Yield
```ruby 
def block_test
  puts "Yielding to the block..."
  yield
  puts "We're back in the method!"
end

block_test { puts ">>> We're in the block!" }

def yield_name(name)
  puts "In the method! Let's yield."
  yield("Kim")
  puts "In between the yields!"
  yield(name)
  puts "Block complete! Back in the method."
end

yield_name("Eric") { |n| puts "My name is #{n}." }

# Now call the method with your name!
yield_name("Roma") { |n| puts "My name is #{n}"}

# provide expression as a parameter to the yield func

def double(num)
  yield
end

double(16) {|x| puts x * 2}
```
DRY -> Don't Repeat Yourself


```ruby 
def greeter
  yield
end

phrase = Proc.new do
  puts "Hello there!"
end

greeter(&phrase)

# with method call
hi = Proc.new do 
  puts "Hello!"
end

hi.call

# You can use the default method in Proc
numbers_array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
strings_array = numbers_array.map(&:to_s)
puts strings_array

```